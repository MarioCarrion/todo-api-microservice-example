// Code generated by counterfeiter. DO NOT EDIT.
package servicetesting

import (
	"context"
	"sync"

	"github.com/MarioCarrion/todo-api-microservice-example/internal"
	"github.com/MarioCarrion/todo-api-microservice-example/internal/service"
)

type FakeTaskMessageBrokerPublisher struct {
	CreatedStub        func(context.Context, internal.Task) error
	createdMutex       sync.RWMutex
	createdArgsForCall []struct {
		arg1 context.Context
		arg2 internal.Task
	}
	createdReturns struct {
		result1 error
	}
	createdReturnsOnCall map[int]struct {
		result1 error
	}
	DeletedStub        func(context.Context, string) error
	deletedMutex       sync.RWMutex
	deletedArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deletedReturns struct {
		result1 error
	}
	deletedReturnsOnCall map[int]struct {
		result1 error
	}
	UpdatedStub        func(context.Context, internal.Task) error
	updatedMutex       sync.RWMutex
	updatedArgsForCall []struct {
		arg1 context.Context
		arg2 internal.Task
	}
	updatedReturns struct {
		result1 error
	}
	updatedReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTaskMessageBrokerPublisher) Created(arg1 context.Context, arg2 internal.Task) error {
	fake.createdMutex.Lock()
	ret, specificReturn := fake.createdReturnsOnCall[len(fake.createdArgsForCall)]
	fake.createdArgsForCall = append(fake.createdArgsForCall, struct {
		arg1 context.Context
		arg2 internal.Task
	}{arg1, arg2})
	stub := fake.CreatedStub
	fakeReturns := fake.createdReturns
	fake.recordInvocation("Created", []interface{}{arg1, arg2})
	fake.createdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskMessageBrokerPublisher) CreatedCallCount() int {
	fake.createdMutex.RLock()
	defer fake.createdMutex.RUnlock()
	return len(fake.createdArgsForCall)
}

func (fake *FakeTaskMessageBrokerPublisher) CreatedCalls(stub func(context.Context, internal.Task) error) {
	fake.createdMutex.Lock()
	defer fake.createdMutex.Unlock()
	fake.CreatedStub = stub
}

func (fake *FakeTaskMessageBrokerPublisher) CreatedArgsForCall(i int) (context.Context, internal.Task) {
	fake.createdMutex.RLock()
	defer fake.createdMutex.RUnlock()
	argsForCall := fake.createdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskMessageBrokerPublisher) CreatedReturns(result1 error) {
	fake.createdMutex.Lock()
	defer fake.createdMutex.Unlock()
	fake.CreatedStub = nil
	fake.createdReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskMessageBrokerPublisher) CreatedReturnsOnCall(i int, result1 error) {
	fake.createdMutex.Lock()
	defer fake.createdMutex.Unlock()
	fake.CreatedStub = nil
	if fake.createdReturnsOnCall == nil {
		fake.createdReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createdReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskMessageBrokerPublisher) Deleted(arg1 context.Context, arg2 string) error {
	fake.deletedMutex.Lock()
	ret, specificReturn := fake.deletedReturnsOnCall[len(fake.deletedArgsForCall)]
	fake.deletedArgsForCall = append(fake.deletedArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeletedStub
	fakeReturns := fake.deletedReturns
	fake.recordInvocation("Deleted", []interface{}{arg1, arg2})
	fake.deletedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskMessageBrokerPublisher) DeletedCallCount() int {
	fake.deletedMutex.RLock()
	defer fake.deletedMutex.RUnlock()
	return len(fake.deletedArgsForCall)
}

func (fake *FakeTaskMessageBrokerPublisher) DeletedCalls(stub func(context.Context, string) error) {
	fake.deletedMutex.Lock()
	defer fake.deletedMutex.Unlock()
	fake.DeletedStub = stub
}

func (fake *FakeTaskMessageBrokerPublisher) DeletedArgsForCall(i int) (context.Context, string) {
	fake.deletedMutex.RLock()
	defer fake.deletedMutex.RUnlock()
	argsForCall := fake.deletedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskMessageBrokerPublisher) DeletedReturns(result1 error) {
	fake.deletedMutex.Lock()
	defer fake.deletedMutex.Unlock()
	fake.DeletedStub = nil
	fake.deletedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskMessageBrokerPublisher) DeletedReturnsOnCall(i int, result1 error) {
	fake.deletedMutex.Lock()
	defer fake.deletedMutex.Unlock()
	fake.DeletedStub = nil
	if fake.deletedReturnsOnCall == nil {
		fake.deletedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskMessageBrokerPublisher) Updated(arg1 context.Context, arg2 internal.Task) error {
	fake.updatedMutex.Lock()
	ret, specificReturn := fake.updatedReturnsOnCall[len(fake.updatedArgsForCall)]
	fake.updatedArgsForCall = append(fake.updatedArgsForCall, struct {
		arg1 context.Context
		arg2 internal.Task
	}{arg1, arg2})
	stub := fake.UpdatedStub
	fakeReturns := fake.updatedReturns
	fake.recordInvocation("Updated", []interface{}{arg1, arg2})
	fake.updatedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskMessageBrokerPublisher) UpdatedCallCount() int {
	fake.updatedMutex.RLock()
	defer fake.updatedMutex.RUnlock()
	return len(fake.updatedArgsForCall)
}

func (fake *FakeTaskMessageBrokerPublisher) UpdatedCalls(stub func(context.Context, internal.Task) error) {
	fake.updatedMutex.Lock()
	defer fake.updatedMutex.Unlock()
	fake.UpdatedStub = stub
}

func (fake *FakeTaskMessageBrokerPublisher) UpdatedArgsForCall(i int) (context.Context, internal.Task) {
	fake.updatedMutex.RLock()
	defer fake.updatedMutex.RUnlock()
	argsForCall := fake.updatedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskMessageBrokerPublisher) UpdatedReturns(result1 error) {
	fake.updatedMutex.Lock()
	defer fake.updatedMutex.Unlock()
	fake.UpdatedStub = nil
	fake.updatedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskMessageBrokerPublisher) UpdatedReturnsOnCall(i int, result1 error) {
	fake.updatedMutex.Lock()
	defer fake.updatedMutex.Unlock()
	fake.UpdatedStub = nil
	if fake.updatedReturnsOnCall == nil {
		fake.updatedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskMessageBrokerPublisher) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTaskMessageBrokerPublisher) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.TaskMessageBrokerPublisher = new(FakeTaskMessageBrokerPublisher)
